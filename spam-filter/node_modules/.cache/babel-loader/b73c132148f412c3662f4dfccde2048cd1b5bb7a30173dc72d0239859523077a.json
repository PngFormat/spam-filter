{"ast":null,"code":"const localList = require('./lang.json').words;\nconst baseList = require('badwords-list').array;\nclass Filter {\n  /**\r\n   * Filter constructor.\r\n   * @constructor\r\n   * @param {object} options - Filter instance options\r\n   * @param {boolean} options.emptyList - Instantiate filter with no blacklist\r\n   * @param {array} options.list - Instantiate filter with custom list\r\n   * @param {string} options.placeHolder - Character used to replace profane words.\r\n   * @param {string} options.regex - Regular expression used to sanitize words before comparing them to blacklist.\r\n   * @param {string} options.replaceRegex - Regular expression used to replace profane words with placeHolder.\r\n   * @param {string} options.splitRegex - Regular expression used to split a string into words.\r\n   */\n  constructor(options = {}) {\n    Object.assign(this, {\n      list: options.emptyList && [] || Array.prototype.concat.apply(localList, [baseList, options.list || []]),\n      exclude: options.exclude || [],\n      splitRegex: options.splitRegex || /\\b/,\n      placeHolder: options.placeHolder || '*',\n      regex: options.regex || /[^a-zA-Z0-9|\\$|\\@]|\\^/g,\n      replaceRegex: options.replaceRegex || /\\w/g\n    });\n  }\n\n  /**\r\n   * Determine if a string contains profane language.\r\n   * @param {string} string - String to evaluate for profanity.\r\n   */\n  isProfane(string) {\n    return this.list.filter(word => {\n      const wordExp = new RegExp(`\\\\b${word.replace(/(\\W)/g, '\\\\$1')}\\\\b`, 'gi');\n      return !this.exclude.includes(word.toLowerCase()) && wordExp.test(string);\n    }).length > 0 || false;\n  }\n\n  /**\r\n   * Replace a word with placeHolder characters;\r\n   * @param {string} string - String to replace.\r\n   */\n  replaceWord(string) {\n    return string.replace(this.regex, '').replace(this.replaceRegex, this.placeHolder);\n  }\n\n  /**\r\n   * Evaluate a string for profanity and return an edited version.\r\n   * @param {string} string - Sentence to filter.\r\n   */\n  clean(string) {\n    return string.split(this.splitRegex).map(word => {\n      return this.isProfane(word) ? this.replaceWord(word) : word;\n    }).join(this.splitRegex.exec(string)[0]);\n  }\n\n  /**\r\n   * Add word(s) to blacklist filter / remove words from whitelist filter\r\n   * @param {...string} word - Word(s) to add to blacklist\r\n   */\n  addWords() {\n    let words = Array.from(arguments);\n    this.list.push(...words);\n    words.map(word => word.toLowerCase()).forEach(word => {\n      if (this.exclude.includes(word)) {\n        this.exclude.splice(this.exclude.indexOf(word), 1);\n      }\n    });\n  }\n\n  /**\r\n   * Add words to whitelist filter\r\n   * @param {...string} word - Word(s) to add to whitelist.\r\n   */\n  removeWords() {\n    this.exclude.push(...Array.from(arguments).map(word => word.toLowerCase()));\n  }\n}\nmodule.exports = Filter;","map":{"version":3,"names":["localList","require","words","baseList","array","Filter","constructor","options","Object","assign","list","emptyList","Array","prototype","concat","apply","exclude","splitRegex","placeHolder","regex","replaceRegex","isProfane","string","filter","word","wordExp","RegExp","replace","includes","toLowerCase","test","length","replaceWord","clean","split","map","join","exec","addWords","from","arguments","push","forEach","splice","indexOf","removeWords","module","exports"],"sources":["C:/Users/Пользователь/OneDrive/Desktop/spam-filter/spam-filter/node_modules/bad-words/lib/badwords.js"],"sourcesContent":["const localList = require('./lang.json').words;\r\nconst baseList = require('badwords-list').array;\r\n\r\nclass Filter {\r\n\r\n  /**\r\n   * Filter constructor.\r\n   * @constructor\r\n   * @param {object} options - Filter instance options\r\n   * @param {boolean} options.emptyList - Instantiate filter with no blacklist\r\n   * @param {array} options.list - Instantiate filter with custom list\r\n   * @param {string} options.placeHolder - Character used to replace profane words.\r\n   * @param {string} options.regex - Regular expression used to sanitize words before comparing them to blacklist.\r\n   * @param {string} options.replaceRegex - Regular expression used to replace profane words with placeHolder.\r\n   * @param {string} options.splitRegex - Regular expression used to split a string into words.\r\n   */\r\n  constructor(options = {}) {\r\n    Object.assign(this, {\r\n      list: options.emptyList && [] || Array.prototype.concat.apply(localList, [baseList, options.list || []]),\r\n      exclude: options.exclude || [],\r\n      splitRegex: options.splitRegex || /\\b/,\r\n      placeHolder: options.placeHolder || '*',\r\n      regex: options.regex || /[^a-zA-Z0-9|\\$|\\@]|\\^/g,\r\n      replaceRegex: options.replaceRegex || /\\w/g\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Determine if a string contains profane language.\r\n   * @param {string} string - String to evaluate for profanity.\r\n   */\r\n  isProfane(string) {\r\n    return this.list\r\n      .filter((word) => {\r\n        const wordExp = new RegExp(`\\\\b${word.replace(/(\\W)/g, '\\\\$1')}\\\\b`, 'gi');\r\n        return !this.exclude.includes(word.toLowerCase()) && wordExp.test(string);\r\n      })\r\n      .length > 0 || false;\r\n  }\r\n\r\n  /**\r\n   * Replace a word with placeHolder characters;\r\n   * @param {string} string - String to replace.\r\n   */\r\n  replaceWord(string) {\r\n    return string\r\n      .replace(this.regex, '')\r\n      .replace(this.replaceRegex, this.placeHolder);\r\n  }\r\n\r\n  /**\r\n   * Evaluate a string for profanity and return an edited version.\r\n   * @param {string} string - Sentence to filter.\r\n   */\r\n  clean(string) {\r\n    return string.split(this.splitRegex).map((word) => {\r\n      return this.isProfane(word) ? this.replaceWord(word) : word;\r\n    }).join(this.splitRegex.exec(string)[0]);\r\n  }\r\n\r\n  /**\r\n   * Add word(s) to blacklist filter / remove words from whitelist filter\r\n   * @param {...string} word - Word(s) to add to blacklist\r\n   */\r\n  addWords() {\r\n    let words = Array.from(arguments);\r\n\r\n    this.list.push(...words);\r\n\r\n    words\r\n      .map(word => word.toLowerCase())\r\n      .forEach((word) => {\r\n        if (this.exclude.includes(word)) {\r\n          this.exclude.splice(this.exclude.indexOf(word), 1);\r\n        }\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Add words to whitelist filter\r\n   * @param {...string} word - Word(s) to add to whitelist.\r\n   */\r\n  removeWords() {\r\n    this.exclude.push(...Array.from(arguments).map(word => word.toLowerCase()));\r\n  }\r\n}\r\n\r\nmodule.exports = Filter;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}